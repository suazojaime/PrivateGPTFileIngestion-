import os
import stat
import shutil
import sys

from abc import ABCMeta, abstractmethod

# Global variable for accessing the last error of any operation
lastError = ""

# Whether we have given a fallback warning
fallbackWarning = False


def getLastError():
    """Return the last error generated by a symlink operation"""
    return lastError


def _exec(cmdline):
    """Execute command line and store any error output in lastError"""
    import subprocess
    global lastError
    child = subprocess.Popen(cmdline, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, close_fds=False)
    (out, err) = child.communicate()
    result = child.returncode
    if result is not 0:
        lastError = ""
        if out:
            lastError += out
        if err:
            lastError += err
    return result


if sys.platform.startswith("win"):
    import junctions
    

class SymlinkError(IOError):
    """ Error raised when there is a symlink error. """
    pass


class SymlinkPrivilegeError(SymlinkError):
    """ Error raised when the caller does not have the necessary privilege for symlinks. """
    pass


class SymbolicLink(object):
    
    """ Class for abstracting symbolic link operations. """

    _instance = None
    
    @classmethod
    def getInstance(cls):
        if SymbolicLink._instance is None:
            SymbolicLink._instance = SymbolicLink()
        return SymbolicLink._instance
    
    def __init__(self):
        self.delegate = _createSymbolicLinkDelegate()

    def hasCreateSymbolicLinkPrivilege(self):
        """ Determine if the caller has sufficient privileges to create symbolic links. """
        return self.delegate.hasCreateSymbolicLinkPrivilege()
    
    def isLink(self, path):
        """ Determine if the path represent a symbolic link. """
        if path is None or not os.path.exists(path):
            return False
        # Send request to delegate.
        return self.delegate.isLink(path)
    
    def resolveLink(self, path):
        """ Resolve a symbolic link to its target. That target may also be a symbolic link. """
        # Verify that the target is a symbolic link.
        if path is None:
            raise ValueError("No symlink specified.")
        if not self.isLink(path):
            raise SymlinkError('Link to resolve is not a symbolic link: "%s"' % path)
        # Send request to delegate.
        return self.delegate.resolveLink(path)
    
    def createLink(self, link, target):
        """ 
        Create a symbolic link from 'link' to 'target', e.g. createLink('/mstar/mstarHome',
        '/mstar/mstar4.4.1') will create a symlink from '/mstar/mstarHome' to the existing
        directory '/mstar/mstar4.4.1'.
         
        :param link: the link to to be created, as a fully-qualified path. Must not be None,
         and the path must not already exist.
         
        :param target: the target of the symlink, as a fully-qualified path. Must not be None,
         and the path must exist.
         
        :return: True if the symlink was created, False otherwise.
        
        :raise ValueError: if 'link' or 'target' are None
        :raise SymlinkError: if 'link' exists, or 'target' does not exist. 
        """
        # Pre-condition checks.
        if link is None:
            raise ValueError("Cannot create symlink: no link specified.")
        if os.path.exists(link):
            raise SymlinkError("Cannot create symlink: link '%s' already exists." % link)
        if target is None:
            raise ValueError("Cannot create symlink: no target specified.")
        if not os.path.exists(target):
            raise SymlinkError("Cannot create symlink: target '%s' does not exist." % target)
        # Send request to delegate.
        return self.delegate.createLink(link, target)
    
    def removeLink(self, path):
        """ Remove a symbolic link. """
        # Verify that the path represents a symbolic link.
        if path is None:
            raise ValueError("No link specified.")
        if not self.isLink(path):
            raise SymlinkError('Link to remove is not a symbolic link: "%s"' % path)
        # Send request to delegate.
        return self.delegate.removeLink(path)

    
def hasCreateSymlinkPrivilege():
    """ Determines if the caller has privilege to create symbolic links. """
    return SymbolicLink.getInstance().hasCreateSymbolicLinkPrivilege()


def _createSymbolicLinkDelegate():
    # global fallbackWarning
    platform = os.sys.platform
    if platform.startswith("win"):
        return _WindowsSymbolicLinkDelegate()
    elif platform.startswith("linux"):
        return _UnixSymbolicLinkDelegate()
    raise SymlinkError("Cannot process symbolic links for platform %s." % platform)
    

class _SymbolicLinkDelegate(object):

    """Interface for symbolic link operations. """
    
    __metaclass__ = ABCMeta
    
    @abstractmethod
    def hasCreateSymbolicLinkPrivilege(self):
        """ Return True if the caller has privilege to create symbolic links. """
        raise NotImplementedError("Cannot check user privileges on this platform.")
    
    @abstractmethod
    def isLink(self, target):
        raise NotImplementedError("Cannot determine symlinks on this platform.")
    
    @abstractmethod
    def resolveLink(self, target):
        raise NotImplementedError("Cannot read symlinks on this platform.")
    
    @abstractmethod
    def createLink(self, link, target):
        raise NotImplementedError("Cannot create symlinks on this platform.")
    
    @abstractmethod
    def removeLink(self, link):
        raise NotImplementedError("Cannot remove symlinks on this platform.")


class _UnixSymbolicLinkDelegate(_SymbolicLinkDelegate):
    
    """ Unix implementation of SymbolicLink operations. """
    
    # @Override
    def hasCreateSymbolicLinkPrivilege(self):
        # Assume true for now.
        return True
    
    # @Override
    def isLink(self, target):
        assert target is not None
        return os.path.islink(target)
    
    # TODO improve resolveLink()
    # @Override
    def resolveLink(self, target):
        assert target is not None
        return os.readlink(target)

    # @Override
    def createLink(self, link, target):
        assert link is not None
        assert target is not None
        try:
            os.symlink(target, link)
        except Exception as e:
            raise SymlinkError(e)
        return True

    # @Override
    def removeLink(self, link):
        assert link is not None
        if os.path.lexists(link):
            os.remove(link)
        return True
    

class _WindowsSymbolicLinkDelegate(_SymbolicLinkDelegate):
    
    """ Windows implementation of SymbolicLink operations. Assumes that caller has symlink privileges. """

    def __init__(self):
        self._privileges = None
        self._createSymbolicLinkPrivilege = None
        
    # @Override
    def hasCreateSymbolicLinkPrivilege(self):
        if self._createSymbolicLinkPrivilege is None:
            self._createSymbolicLinkPrivilege = self._loadHasCreateSymbolicLinkPrivilege()
        return self._createSymbolicLinkPrivilege
    
    def _loadHasCreateSymbolicLinkPrivilege(self):
        import win_privs
        def hasRequiredPrivilege():
            return win_privs.has_privilege("SeCreateSymbolicLinkPrivilege")
        def enableSymbolicLinkPrivilege():
            return win_privs.enable_symlink_privilege()
        # Check if the user has the 'create symbolic link' privilege. If not,
        # try to enable the privilege and re-check the privilege.
        hasPrivilege = hasRequiredPrivilege()
        if not hasPrivilege and enableSymbolicLinkPrivilege():
            hasPrivilege = hasRequiredPrivilege()
        return hasPrivilege
    
    # @Override
    def isLink(self, target):
        try:
            return junctions.islink(target)
        except Exception:
            return False

    # @Override
    def resolveLink(self, target):
        return junctions.readlink(target)
    
    # @Override
    def createLink(self, link, target):
        action = self.__getCreateSymlinkAction(link, target)
        
        # print 'createLink() link="%s"' % link
        # print 'createLink() target="%s"' % target
        # print 'createLink()   action=%s' % action
        
        if action == SymlinkAction.Error:
            raise SymlinkError("Cannot create symlink: unspecified error")
        elif action == SymlinkAction.CreateFileSymbolicLink:
            return self.__createFileSymbolicLink(link, target)
        elif action == SymlinkAction.CreateJunction:
            return self.__createJunction(link, target)
        elif action == SymlinkAction.UpdateJunction:
            return self.__removeJunction(link) and self.__createJunction(link, target)
        
        return True

    # @Override
    def removeLink(self, link):
        # print 'Removing symbolic link "' + link + '" ...'
        # Do not need SeCreateSymbolicLink privilege to remove a symbolic link or junction.
        return self.__removeJunction(link) if os.path.isdir(link) else self.__removeFileSymbolicLink(link)

    def __createFileSymbolicLink(self, link, target):
        """ Create a symbolic link to a file. Note that SeCreateSymbolicLink privilege must be enabled. """
        # print 'Creating symbolic link from "%s" to "%s" ...' % (link, target)
        if not hasCreateSymlinkPrivilege():
            raise SymlinkPrivilegeError("Insufficient privileges to to create symbolic link")
        return _exec('mklink "%s" "%s"' % (link, target)) == 0

    def __removeFileSymbolicLink(self, link):
        return _exec('del "%s"' % link) == 0

    def __createJunction(self, link, target):
        # print 'Creating junction from "%s" to "%s" ...' % (link, target)
        return _exec('mklink /J "%s" "%s"' % (link, target)) == 0

    def __removeJunction(self, link):
        # print 'Removing junction from ' + link + ' to ' + junctions.readlink(link)
        return _exec('rmdir "%s"' % link) == 0

    def __getCreateSymlinkAction(self, link, target):
        # Make sure that the target exists.
        if not os.path.exists(target):
            raise SymlinkError("Cannot create symlink: target does not exist.")

        # If there is no file for the link, then create the symbolic link.
        if not os.path.exists(link):
            return SymlinkAction.CreateJunction if os.path.isdir(target) else SymlinkAction.CreateFileSymbolicLink

        # Assert: there is a file for the link.

        # If the file is not a symbolic link (e.g. it is a normal file or directory)
        # then fail.
        if not junctions.islink(link):
            raise SymlinkError("Cannot create symlink: link exists but is not a symlink.")

        # Assert: the link exists and represents a symbolic link.

        # Get the target of the existing link, and check that it exists. If
        # not, need to update the symbolic link.
        linkedTarget = junctions.readlink(link)
        if not os.path.exists(linkedTarget):
            return SymlinkAction.UpdateJunction

        # Assert: the target of the link exists.

        # Check if the linked target is the same as the proposed target.
        if os.path.normpath(linkedTarget) == os.path.normpath(target):
            return SymlinkAction.Nothing

        # The existing symbolic link is to some other target (e.g. an older
        # version of a package) so it should be updated.
        return SymlinkAction.UpdateJunction


# TODO: There aspects of the way this works that probably should be included or merged with the
# existing WindowsSymbolicLink delegate behaviour.
class _WindowsHardLinkOrCopyFallbackDelegate(_SymbolicLinkDelegate):
    """Fallback implementation of Symlink operations using copy"""

    def isLink(self, target):
        return junctions.islink(target)

    def resolveLink(self, target):
        if self.isLink(target):
            return junctions.readlink(target)
        raise SymlinkError("Cannot resolve symbolic link: '%s' is not a junction" % target)

    def createLink(self, link, target):
        global lastError

        action = self.__getSymlinkAction(link, target)
        # print 'createLink() link="%s", target="%s", action=%s' % (link, target, action)

        try:
            if action == SymlinkAction.Error:
                return False
            elif action == SymlinkAction.CreateFileSymbolicLink:
                return self.__createFileSymbolicLink(link, target)
            elif action == SymlinkAction.CreateJunction:
                return self.__createJunction(link, target)
            elif action == SymlinkAction.UpdateSymlink:
                return self.__createFileSymbolicLink(link, target)
            elif action == SymlinkAction.UpdateJunction:
                return self.__removeJunction(link) and self.__createJunction(link, target)
            return True
        except os.error as e:
            lastError = str(e)
            return False

    def __updateJunction(self, link, target):
        if _exec('mklink /J "%s" "%s"' % (link, target)) == 0:
            return _exec('robocopy %s %s /np /nfl /MIR /Z /XA:H /W:5' % target, link) == 0

    def __removeJunction(self, link):
        # Remove junction
        if _exec('rmdir "%s"' % link) == 0:
            # Fallback to a rmtree
            shutil.rmree(link)
        return True

    def __createJunction(self, link, target):
        # Create a Junction
        if _exec('mklink /J "%s" "%s"' % (link, target)) == 0:
            # Fallback to a directory copy
            shutil.copytree(target, link)
        return True

    def __createFileSymbolicLink(self, link, target):
        # Attempt a hard link - needs to be on the same volume
        if _exec('mklink /h "%s" "%s"' % (link, target)) != 0:
            # Fallback to a copy
            shutil.copy2(target, link)
        return True

    def removeLink(self, link):
        # print '## WindowsHardLink::removeLink() Removing symbolic link "' + link + '" ...'
        return shutil.rmtree(link) if os.path.isdir(link) else os.remove(link)

    def __getSymlinkAction(self, link, target):
        global lastError

        # Make sure that the target exists.
        if not os.path.exists(target):
            lastError = "Target does not exist"
            return SymlinkAction.Error

        # If there is no file for the link, then we will copy it
        if not os.path.exists(link):
            return SymlinkAction.CreateJunction if os.path.isdir(target) else SymlinkAction.CreateFileSymbolicLink

        if os.path.isdir(target):
            return SymlinkAction.UpdateJunction

        # HACK: This assumes the files are the same if they have the same size and modification time
        targetStats = os.stat(target)
        linkStats = os.stat(link)
        if targetStats[stat.ST_SIZE] != linkStats[stat.ST_SIZE] or targetStats[stat.ST_MTIME] != linkStats[stat.ST_MTIME]:
            return SymlinkAction.Nothing
        return SymlinkAction.UpdateSymlink

class SymlinkAction:

    # Report an error.
    Error = 'Error'

    # Create a file symbolic link.
    CreateFileSymbolicLink = 'Create File Symbolic Link'

    # Create a directory junction.
    CreateJunction = 'Create Directory Junction'

    # Update a directory junction.
    UpdateJunction ='Update Directory Junction'

    # Update a Symlink
    UpdateSymlink = 'Update Symbolic Link'

    # No action required.
    Nothing = 'No Action'

def isSymbolicLink(path):
    """ Determine if the path represent a symbolic link. """
    return SymbolicLink.getInstance().isLink(path)


def resolveSymbolicLink(path, recursive=False):
    """ 
    Resolve a symbolic link to its target. Note that the target may itself be a symbolic link that also needs
    resolving.
    
    :param path: the path to be resolved. Must not be None. Must be a symbolic link.
    
    :param recursive: indicates if a path that resolves to a symbolic link should also be resolved, until
     the path resolves to an actual resource on the file system, or a cycle is detected. Defaults to False.
    
    :returns: the resolved path.
    
    :raises SymlinkError: if a cycle is detected when resolving the path.
    
    """
    symbolicLink = SymbolicLink.getInstance()
    # Resolve the path to its immediate target.
    resolvedPath = symbolicLink.resolveLink(path)
    if recursive:
        # Note which paths have already been seen.
        resolvedPaths = [path, resolvedPath]
        # Repeatedly resolve the path if it is a symbolic link, checking for cycles.
        while symbolicLink.isLink(resolvedPath):
            resolvedPath = symbolicLink.resolveLink(resolvedPath)
            # Fail if the resolved path has already been seen.
            if resolvedPath in resolvedPaths:
                raise SymlinkError('Detected cycle when resolving symbolic link "' + path + '"')
            # Add the resolved path to the collection of known resolved paths.
            resolvedPaths.append(resolvedPath)
    return resolvedPath

def resolvePossibleSymbolicLink(path, recursive=False):
    """ 
    Resolve the path if it is a symbolic link. 
    
    :param path: the path to be resolved.
    :param recursive: indicates if path should be resolved again if it resolves to a symlink. Defaults
    to False.
    
    :returns: the supplied path if the path is not a symbolic link, otherwise returns 
    the resolved path.
    """
    return path if not isSymbolicLink(path) else resolveSymbolicLink(path, recursive)

def createSymbolicLink(link, target):
    """ Create a symbolic link from 'link' to 'target'. If successful, then isSymbolicLink(link) returns
        True, and resolveSymbolicLink(link) returns the target. """
    return SymbolicLink.getInstance().createLink(link, target)


def removeSymbolicLink(path):
    """ Remove a symbolic link. Will not remove the target of the symbolic link. """
    return SymbolicLink.getInstance().removeLink(path)

