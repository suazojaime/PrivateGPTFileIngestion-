# *********************************************************************************************************
#
# Copyright 2020 Caterpillar Inc.
#
# AssignmentRecorderReader.py - a python3 library for dealing with MineStar AssignmentRecorder JSON output.
#
# *********************************************************************************************************

import json
from datetime import datetime

# Assignment Trigger Map:
assignmentTriggers = {
    0 : 'UNKNOWN',
    1 : 'OPERATOR_REQUEST',
    2 : 'OFFICE_REQUEST',
    3 : 'MANUAL',
    4 : 'WAYPOINT',
    5 : 'COURSE',
    6 : 'START_SERVICE',
    7 : 'END_SERVICE',
    8 : 'MATERIAL_CHANGE',
    9 : 'ASS_INVALID',
    10 : 'OPER_LDR_CHANGE',
    11 : 'END_DELAY',
    12 : 'ASAP_SCHEDULED',
    13 : 'BAD_COMMS',
    14 : 'SYSTEM_RESTART',
    15 : 'INTERNAL',
    16 : 'TRAFFIC_MANAGEMENT',
    17 : 'REASSIGNMENT_LANE',
    18 : 'MADE_AVAILABLE',
    19 : 'LANE_CHANGE',
    20 : 'PATH_CHANGE',
    21 : 'SERVER_END_DELAY',
    22 : 'SERVER_START_DELAY',
    23 : 'PATH_DELAY',
    24 : 'ASSIGNABILITY_REASSIGN_ON_ROUTE',
    25 : 'ASSIGNABILITY_REASSIGN_QUEUED',
    26 : 'GO_BUTTON',
    27 : 'TRUCK_KNOWN_STATE'
}

# RCM value matching regex:
def rcmValue(source):
    prefix = source[:3]
    if prefix != 'NUM':
        return source[3:]
    else:
        return source[4:]

class AssignmentRecorderReader:
    """A library to process the JSON output of the mstarrun target AssignmentRecorderConverter -mjson"""

    class Event:
        """A base class for all AssignmentRecorder event types."""

        def __init__(self, time, eventType, data):
            """Constructor for internal use.

            Args:
              time:
                Epoch milliseconds timestamp of the event.
              eventType:
                The type of the event as a string
              data:
                The JSON node of the event content
            """
            self.time = time
            self.eventType = eventType
            self.data = data

        def getTime(self):
            """
              Returns:
                the event time in epoch milliseconds
            """
            return self.time

        def getType(self):
            """
              Returns:
                The event type as a string
            """
            return self.eventType

        def getData(self):
            """
              Returns:
                the JSON content of this event
            """
            return self.data

    class ConfigurationEvent(Event):
        """AssignmentRecorder configuration events."""

        def __init__(self, time, data):
            """Constructor for internal use

            Args:
              time:
                Epoch milliseconds timestamp of the event.
              data:
                The JSON node of the recorder configuration event content
            """
            super(AssignmentRecorderReader.ConfigurationEvent, self).__init__(time, "CONFIGURATION", data)

    class RCMEvent(Event):
        """AssignmentRecorder event containing a full RCM configuration."""

        def __init__(self, time, data):
            """Constructor for internal use

            Args:
              time:
                Epoch milliseconds timestamp of the event.
              data:
                The JSON node of the full RCM event content
            """
            super(AssignmentRecorderReader.RCMEvent, self).__init__(time, "RCM_XML", data)
            self.mapEntitiesByOID(data)

        def mapEntitiesByOID(self, node):
            """Map or re-map all RCM entities by OID - for internal use only by constructor
            """
            self.entitiesByOID = {}
            fullConfigNode = node["children"][0]
            if fullConfigNode:
                rcmNode = fullConfigNode["children"][0]
                for rcmChildNode in rcmNode["children"]:
                    if "name" in rcmChildNode:
                        if rcmChildNode["name"] == "rcme":
                            rcmEntityOID = rcmChildNode["attributes"]["oid"]
                            self.entitiesByOID[rcmEntityOID] = AssignmentRecorderReader.RCM.Entity(
                                rcmEntityOID, rcmChildNode
                            )

        def getEntitiesByOID(self):
            """
            Returns:
              a map of entities by OID, as generated by mapEntitiesByOID()
            """
            return self.entitiesByOID

    class RCMUpdateEvent(Event):
        """Read Consistent Model Update events"""

        # From the source XML, there are several structures for entity creation and updates:
        #
        #   creation:
        #  
        #   <diffConfig>
        #     <entupd>
        #       <entchg>
        #         <oid>1215251</oid>
        #         <created>
        #           <rcme oid=....>               - extra node
        #             <att blah="bleen"/>
        #             <att bleh="bleen"/>
        #             ...
        #           </rcme>
        #         </created>
        #       </entchg>
        #     </entupd>
        #   </diffConfig>
        #  
        #   modification:
        #  
        #   <diffConfig>
        #     <entupd>
        #       <entchg>
        #         <oid>12323515</oid>
        #         <mod>
        #           <att blah="bleen"/>
        #           <att blah2="bleen2"/>
        #         </mod>
        #       </entchg>
        #       <entchg>
        #         <oid>12323516</oid>
        #         <mod>
        #           <att blah="bleen"/>
        #           <att blah2="bleen2"/>
        #         </mod>
        #       </entchg>
        #     </entupd>
        #   </diffConfig>

        def __init__(self, time, data):
            """Constructor for internal use

            Args:
              time:
                Epoch milliseconds timestamp of the event.
              data:
                The JSON node of the event full RCM update content
            """
            super(AssignmentRecorderReader.RCMUpdateEvent, self).__init__(time, "RCM_UPDATE", data)
            self.updatesByOID = {}
            # Iterate over the "entupd" nodes, above:
            if 'children' in data:
                for entityUpdate in data["children"]:
                    entityChanges = entityUpdate["children"]
                    for entityChange in entityChanges:
                        update = self.createUpdateFromEntityChangesList(entityChange)
                        if "oid" in update:
                            updatesForOID = []
                            if update["oid"] in self.updatesByOID:
                                updatesForOID = self.updatesByOID[update["oid"]]
                            else:
                                self.updatesByOID[update["oid"]] = updatesForOID
                            updatesForOID.append(update)
                        else:
                            raise Exception('have an update with no oid')

        def createUpdateFromEntityChangesList(self, entityChange):
            """Creates an update from an engtch JSON node - only for internal use by constructor.
            """
            # Iterate over each "entchg" child of the "entupd" node:
            update = {}
            update["attributes"] = {}
            entityChangeChildren = entityChange["children"]
            # Iterate over each child of the "entchg" node.  There are three types of children to ben considered,
            # "oid", "created" and "mod":
            for entityChangeChild in entityChangeChildren:
                if "name" in entityChangeChild:
                    # An "oid" child is just the object id of the entity (created or modified in the subsequent child):
                    if entityChangeChild["name"] == "oid":
                        update["oid"] = entityChangeChild["content"]
                    # A "created" child is the addition of a new entity (with the oid given in the previous child):
                    elif entityChangeChild["name"] == "created":
                        update["type"] = "created"
                        rcmeNode = entityChangeChild["children"][0]
                        for rcmAttributeNode in rcmeNode["children"]:
                            for key in rcmAttributeNode["attributes"].keys():
                                update["attributes"][key] = rcmValue(rcmAttributeNode["attributes"][key])
                    # A "mod" child is the modification of an existing entity (with the oid given in the previous child):
                    elif entityChangeChild["name"] == "mod":
                        update["type"] = "mod"
                        for rcmAttributeNode in entityChangeChild["children"]:
                            for key in rcmAttributeNode["attributes"].keys():
                                update["attributes"][key] = rcmValue(rcmAttributeNode["attributes"][key])
                else:
                    raise Exception('Found an RCM update entity change child has no name')
            return update

        def getUpdatesByOID(self):
            """
            Returns:
              a map of OIDs to lists of JSON update nodes in the event
            """
            return self.updatesByOID

    class TravelTimesEvent(Event):
        """Events with the full set of travel times between locations"""

        def __init__(self, time, data):
            """Constructor for internal use

            Args:
              time:
                Epoch milliseconds timestamp of the event.
              data:
                The JSON node of the full travel times event content
            """
            super(AssignmentRecorderReader.TravelTimesEvent, self).__init__(time, "TRAVEL_TIMES", data)

    class ProductionRequestEvent(Event):
        """Production plan request events"""

        def __init__(self, time, data):
            """Constructor for internal use

            Args:
              time:
                Epoch milliseconds timestamp of the event.
              data:
                The JSON node of the full production request event content
            """
            super(AssignmentRecorderReader.ProductionRequestEvent, self).__init__(time, "PRODUCTION_REQUEST", data)

    class AssignmentEvent(Event):
        """Assignment events"""

        def __init__(self, time, data):
            """Constructor for internal use

            Args:
              time:
                Epoch milliseconds timestamp of the event.
              data:
                The JSON node of the full assignment event content
            """
            super(AssignmentRecorderReader.AssignmentEvent, self).__init__(time, "ASSIGNMENT", data)
            self.truckOID = data["truckOID"]
            self.assignments = data["assignments"]

        def getAssignments(self):
            """
            Returns:
              a list of JSON assignment nodes for this assignment (current plus three future assignments)
            """
            return self.assignments

        def getTruckOID(self):
            """
            Returns:
              the oid of the truck in the assignment.
            """
            return self.truckOID

    class MachineStateChangeEvent(Event):
        """Machine state change events"""

        def __init__(self, time, data):
            """Constructor for internal use

            Args:
              time:
                Epoch milliseconds timestamp of the event.
              data:
                The JSON node of the event full machine state change content
            """
            super(AssignmentRecorderReader.MachineStateChangeEvent, self).__init__(time, "MACHINE_STATE_CHANGE", data)

    class DelayChangeEvent(Event):
        """Delay change events for changes in non-assignment truck delays"""

        def __init__(self, time, data):
            """Constructor for internal use

            Args:
              time:
                Epoch milliseconds timestamp of the event.
              data:
                The JSON node of the full delay change event content
            """
            super(AssignmentRecorderReader.DelayChangeEvent, self).__init__(time, "DELAY_CHANGE", data)

    class ProductionPlanRequestEvent(Event):
        """Production plan request events"""

        def __init__(self, time, data):
            """Constructor for internal use

            Args:
              time:
                Epoch milliseconds timestamp of the event.
              data:
                The JSON node of the full production plan request event content
            """
            super(AssignmentRecorderReader.ProductionPlanRequestEvent, self).__init__(time, "PRODUCTION_PLAN_REQUEST", data)

    class ProductionPlanResultEvent(Event):
        """Production plan result events"""

        def __init__(self, time, data):
            """Constructor for internal use

            Args:
              time:
                Epoch milliseconds timestamp of the event.
              data:
                The JSON node of the full production plan result event content
            """
            super(AssignmentRecorderReader.ProductionPlanResultEvent, self).__init__(time, "PRODUCTION_PLAN_RESULT", data)

    class IgnoredEvent(Event):
        """Placeholder in the event stream for events that are ignored"""

        def __init__(self, time, data):
            """Constructor for internal use

            Args:
              time:
                Epoch milliseconds timestamp of the event.
              data:
                The JSON node of the full ignored event content
            """
            super(AssignmentRecorderReader.IgnoredEvent, self).__init__(time, "IGNORED", data)

    class EventFactory:
        """A factory class for internal use that maps event type strings to factory methods for events"""

        def createConfigurationEvent(self, time, data):
            return AssignmentRecorderReader.ConfigurationEvent(time, data)

        def createRCMEvent(self, time, data):
            return AssignmentRecorderReader.RCMEvent(time, data)

        def createRCMUpdateEvent(self, time, data):
            return AssignmentRecorderReader.RCMUpdateEvent(time, data)

        def createTravelTimesEvent(self, time, data):
            return AssignmentRecorderReader.TravelTimesEvent(time, data)

        def createProductionRequestEvent(self, time, data):
            return AssignmentRecorderReader.ProductionRequestEvent(time, data)

        def createAssignmentEvent(self, time, data):
            return AssignmentRecorderReader.AssignmentEvent(time, data)

        def createMachineStateChangeEvent(self, time, data):
            return AssignmentRecorderReader.MachineStateChangeEvent(time, data)

        def createDelayChangeEvent(self, time, data):
            return AssignmentRecorderReader.DelayChangeEvent(time, data)

        def createProductionPlanRequestEvent(self, time, data):
            return AssignmentRecorderReader.ProductionPlanRequestEvent(time, data)

        def createProductionPlanResultEvent(self, time, data):
            return AssignmentRecorderReader.ProductionPlanResultEvent(time, data)

        def ignoreEvent(self, time, data):
            return AssignmentRecorderReader.IgnoredEvent(time, data)

        def __init__(self):
            # Map the types from the AssignmentRecorder.Event.Type enumeration (Java):
            self.factoryMap = {
                "CONFIGURATION" : self.createConfigurationEvent,
                "RCM_XML" : self.createRCMEvent,
                "RCM_UPDATE" : self.createRCMUpdateEvent,
                "TRAVEL_TIMES" : self.createTravelTimesEvent,
                "PRODUCTION_REQUEST" : self.createProductionRequestEvent,
                "ASSIGNMENT" : self.createAssignmentEvent,
                "MACHINE_STATE_CHANGE" : self.createMachineStateChangeEvent,
                "DELAY_CHANGE" : self.createDelayChangeEvent,
                "PRODUCTION_PLAN_REQUEST" : self.createProductionPlanRequestEvent,
                "PRODUCTION_PLAN_RESULT" : self.createProductionPlanResultEvent,
                "ASH_CYCLE_INFORMATION" : self.ignoreEvent,
                "ASH_CYCLE_START" : self.ignoreEvent,
                "ASH_CYCLE_END" : self.ignoreEvent,
                "OBJECT" : self.ignoreEvent
            }

        def createEvent(self, data):
            eventTime = datetime.strptime(data['time'], '%Y-%m-%d %H:%M:%S.%f')
            eventType = data["type"]
            eventFactory = self.factoryMap.get(eventType)
            return eventFactory(eventTime, data["content"])

    class RCM:
        """A A running RCM that can be reset using an RCMEvent, or modified using an RCMUpdateEvent"""

        class Entity:
            """An entity in the RCM"""

            def __init__(self, oid, data):
                """Constructor for internal use

                Args:
                  oid: the object id of the entity
                  data: the JSON data representing the entity
                """
                self.oid = oid
                self.data = data
                self.attributes = {}
                if 'children' in data:
                    for childNode in data["children"]:
                        if childNode["name"] == "att":
                            childNodeAttributes = childNode["attributes"]
                            for key in childNodeAttributes.keys():
                                self.attributes[key] = rcmValue(childNodeAttributes[key])

            def apply(self, update):
                """Apply an update to the RCM entity
                
                Args:
                  update: the json update node to apply to the RCM entity
                """
                if 'type' in update:
                    if update['type'] == 'created':
                        self.attributes = {}
                        updateAttributes = update['attributes']
                        for key in updateAttributes.keys():
                            self.attributes[key] = updateAttributes[key]
                    elif update['type'] == 'mod':
                        updateAttributes = update['attributes']
                        for key in updateAttributes.keys():
                            self.attributes[key] = updateAttributes[key]

            def getAttribute(self, key):
                """Get an attribute of the entity
                Args:
                  key: the entity attribute string key
                Returns:
                  the entity attribute value
                """
                  
                return self.attributes[key]

            def getName(self):
                """
                Returns:
                  the name of the entity
                """
                if 'name' in self.attributes:
                    return self.getAttribute("name")
                else:
                    return 'UNKNOWN'

        def __init__(self):
            """Void constructor
            """
            self.entitiesByOID = {}

        def __init__(self, rcmEvent):
            """Initialising constructor

            Args:
              rcmEvent: the full RCM event
            """
            self.reset(rcmEvent)

        def reset(self, rcmEvent):
            """Reset the RCM with an initialising event

            Args:
              rcmEvent: the event with which to initialise the RCM
            """
            self.entitiesByOID = rcmEvent.getEntitiesByOID()

        def apply(self, rcmUpdateEvent):
            """Apply an rcm update to the rcm

            Args:
              rcmUpdate: the update JSON node to apply
            """
            rcmUpdatesByOID = rcmUpdateEvent.getUpdatesByOID()
            for oid in rcmUpdatesByOID.keys():
                entity = AssignmentRecorderReader.RCM.Entity(oid, {})
                if oid in self.entitiesByOID:
                    entity = self.entitiesByOID[oid]
                else:
                    self.entitiesByOID[oid] = entity
                rcmUpdatesForOID = rcmUpdatesByOID[oid]
                for update in rcmUpdatesForOID:
                    entity.apply(update)

        def getEntityOIDs(self):
            """
            Returns:
              The list of entity OIDS in the RCM
            """
            return self.entitiesByOID.keys()

        def getEntitiesByOID(self):
            """
            Returns:
              A map of OIDs to entities
            """
            return self.entitiesByOID

        def getEntitiesForOID(self, oid):
            """
            Args:
              an OID for which to return an associated entity.
            Returns:
              the RCM entity
            """
            return self.entitiesByOID[oid]

    def __init__(self, path):
        """Constructor to initialise from a JSON file path
        Args:
          path: the path to a JSON output file from the AssignmentRecorderConverter.  NOTE: this must contain
          an element of the type RCM_XML (JSON converted from XML).  An example command is:

          mstarrun AssignmentRecorderConverter -m json -o data.json SomeAssignmentRecorderDatabase.sqlite
        """
        self.path = path
        self.events = []
        self.eventsByTime = {}
        self.eventsByType = {}
        with open(self.path) as jsonFile:
            self.data = json.load(jsonFile)
            eventFactory = AssignmentRecorderReader.EventFactory()
            for eventData in self.data:
                event = eventFactory.createEvent(eventData)
                self.events.append(event)
                eventTime = event.getTime()
                eventType = event.getType()
                if eventTime in self.eventsByTime:
                    self.eventsByTime[eventTime].append(event)
                else:
                    self.eventsByTime[eventTime] = [ event ]
                if eventType in self.eventsByType:
                    self.eventsByType[eventType].append(event)
                else:
                    self.eventsByType[eventType] = [ event ]

    def getEvents(self):
        """
        Returns:
          a list of events in this RCM
        """
        return self.events

    def getRCMEvent(self):
        """
        Returns:
          the source RCM event of this RCM
        """
        if not hasattr(self, 'rcmEvent'):
            rcmEvents = self.getEventsByType('RCM_XML')
            if len(rcmEvents) == 0:
                raise Exception('No RCM event found')
            # Use the last rcm event found (there should only be one, in any case):
            self.rcmEvent = rcmEvents[len(rcmEvents) - 1]
        return self.rcmEvent

    def getRCMEntitiesByOID(self):
        """
        Returns:
          a map of machine OIDs to RCM entities
        """
        rcmEvent = self.getRCMEvent()
        return rcmEvent.getEntitiesByOID()

    def getRCMUpdatesByTimeByOID(self):
        """
        Returns:
          a map of machine OIDs to maps of times to lists of RCM updates
        """
        if not hasattr(self, 'rcmUpdatesByTimeByOID'):
            self.rcmUpdatesByTimeByOID = {}
            rcmUpdateEvents = self.eventsByType['RCM_UPDATE']
            if rcmUpdateEvents:
                for rcmUpdateEvent in rcmUpdateEvents:
                    eventUpdatesByOID = rcmUpdateEvent.getUpdatesByOID()
                    for oid in eventUpdatesByOID.keys():
                        rcmUpdatesByTimeForOID = {}
                        if oid in self.rcmUpdatesByTimeByOID:
                            rcmUpdatesByTimeForOID = self.rcmUpdatesByTimeByOID[oid]
                        else:
                            self.rcmUpdatesByTimeByOID[oid] = rcmUpdatesByTimeForOID
                        rcmUpdatesForTimeForOID = []
                        # if there is an entry in the map of times to rcm updates for the given oid, use that:
                        if rcmUpdateEvent.getTime() in rcmUpdatesByTimeForOID:
                            rcmUpdatesForTimeForOID = rcmUpdatesByTimeForOID[rcmUpdateEvent.getTime()]
                        # otherwise, use the new empty map as the map of times to rcm updates for the given oid:
                        else:
                            rcmUpdatesByTimeForOID[rcmUpdateEvent.getTime()] = rcmUpdatesForTimeForOID
                        for eventOIDUpdate in eventUpdatesByOID[oid]:
                            rcmUpdatesForTimeForOID.append(eventOIDUpdate)
        return self.rcmUpdatesByTimeByOID

    def getRCMUpdatesByTimeForOID(self, oid):
        """
        Args:
          a machine OID
        Returns:
          a map of times to lists of rcm updates for the given machine OID
        """
        if oid in self.rcmUpdatesByTimeByOID:
            return self.rcmUpdatesByTimeByOID[oid]
        else:
            return {}

    def getCumulativeRCM(self):
        """
        Returns:
          the (current) cumulative RCM in this recorder reader
        """
        if not hasattr(self, 'cumulativeRCM'):
            self.resetCumulativeRCM()
        return self.cumulativeRCM

    def resetCumulativeRCM(self):
        """Resets the cumulative RCM object in this recorder reader to have no entities
        """
        self.cumulativeRCM = AssignmentRecorderReader.RCM(self.getRCMEvent())
        for rcmUpdateEvent in self.getEventsByType('RCM_UPDATE'):
            self.cumulativeRCM.apply(rcmUpdateEvent)
        return self.cumulativeRCM

    def getAssignmentEventsByOID(self):
        """
        Returns:
          a map of truck OIDs to assignment events
        """
        if not hasattr(self, 'assignmentEventsByOID'):
            self.assignmentEventsByOID = {}
            if 'ASSIGNMENT' in self.eventsByType:
                assignmentEvents = self.eventsByType['ASSIGNMENT']
                for assignmentEvent in assignmentEvents:
                    oid = assignmentEvent.getTruckOID()
                    assignmentEventsForOID = []
                    if oid in self.assignmentEventsByOID:
                        assignmentEventsForOID = self.assignmentEventsByOID[oid]
                    else:
                        self.assignmentEventsByOID[oid] = assignmentEventsForOID
                    assignmentEventsForOID.append(assignmentEvent)
        return self.assignmentEventsByOID

    def getAssignmentEventsForOID(self, oid):
        """
        Args:
          oid: the OID of a truck
        Returns:
          a list of assignment events for the given truck OID
        """
        if oid in self.assignmentEventsByOID:
            return self.assignmentEventsByOID[oid]
        else:
            return []

    def getPath(self):
        """
        Returns:
          the source path of this recording (a JSON file path)
        """
        return self.path

    def getData(self):
        """
        Returns:
          the source JSON data for this recording
        """
        return self.data

    def getFormattedData(self):
        """
        Returns:
          a formatted string of the source JSON data for this recording
        """
        return json.dumps(self.data)

    def getEventTimes(self):
        """
        Returns:
          a list of all times at which events occur in the recording
        """
        return self.eventsByTime.keys()

    def getEventsAtTime(self, time):
        """
        Args:
          a datetime
        Returns:
          a list of events in the recording that occur at the given time
        """
        return self.eventsByTime.get(time)

    def getEventTypes(self):
        """
        Returns:
          a list of unique event type strings in the recording
        """
        return self.eventsByType.keys()

    def getEventsByType(self, eventType):
        """
        Args:
          eventType: the string type of the event
        Returns:
          a list of events of the given type
        """
        return self.eventsByType[eventType]

    def getEventCountByType(self, eventType):
        """
        Args:
          eventType: the string type of the event
        Returns:
          A count of events of the given type
        """
        return len(self.eventsByType[eventType])

    def getAssignmentEventsByTruckOID(self):
        """Obtain all assignment events in the recording

        Returns:
          a map of truck OIDs to triggers and assignment events
        """
        self.getCumulativeRCM() # ensures that the cumulative RCM has been created.
        triggersAndAssignmentsByTruckOID = {}
        for event in self.getEvents():
            if event.getType() == 'RCM_UPDATE':
                self.extractTriggersAndAssignmentsFromRCMUpdate(event, triggersAndAssignmentsByTruckOID)
            elif event.getType() == 'ASSIGNMENT':
                self.extractTriggersAndAssignmentsFromAssignment(event, triggersAndAssignmentsByTruckOID)
        self.setTimeDifferencesInTriggersAndAssignmentsByTruckOID(triggersAndAssignmentsByTruckOID)
        return triggersAndAssignmentsByTruckOID

    def extractTriggersAndAssignmentsFromRCMUpdate(self, event, triggersAndAssignmentsByTruckOID):
        """Extract triggers and assignments from an rcm update event - internal use only
        """
        updatesByOID = event.getUpdatesByOID()
        for oid in updatesByOID:
            updates = updatesByOID[oid]
            for update in updates:
                if 'assignmentTrigger' in update['attributes']:
                    truckTriggersAndAssignments = []
                    if oid in triggersAndAssignmentsByTruckOID:
                        truckTriggersAndAssignments = triggersAndAssignmentsByTruckOID[oid]
                    else:
                        triggersAndAssignmentsByTruckOID[oid] = truckTriggersAndAssignments
                    truckTriggersAndAssignments.append(
                        {
                            'time' : event.getTime(),
                            'type' : 'trigger',
                            'trigger' : update['attributes']['assignmentTrigger'],
                        }
                    )
                elif 'timeArrivedAtDestination' in update['attributes']:
                    truckTriggersAndAssignments = []
                    if oid in triggersAndAssignmentsByTruckOID:
                        truckTriggersAndAssignments = triggersAndAssignmentsByTruckOID[oid]
                    else:
                        triggersAndAssignmentsByTruckOID[oid] = truckTriggersAndAssignments
                    arrivalTimeSource = update['attributes']['timeArrivedAtDestination']
                    arrivalTime = datetime.strptime(arrivalTimeSource, '%Y%m%d %H:%M:%S:%f')
                    print("Arrival time source: \"" + arrivalTimeSource + "\" arrivalTime: " + str(arrivalTime))
                    truckTriggersAndAssignments.append(
                        {
                            'time' : event.getTime(),
                            'type' : 'arrival',
                            'arrivalTime' : arrivalTime
                        }
                    )

    def extractTriggersAndAssignmentsFromAssignment(self, event, triggersAndAssignmentsByTruckOID):
        """Extract triggers and assignments from an assignment event - internal use only
        """
        oid =  event.getTruckOID()
        truckTriggersAndAssignments = []
        if oid in triggersAndAssignmentsByTruckOID:
            truckTriggersAndAssignments = triggersAndAssignmentsByTruckOID[oid]
        else:
            triggersAndAssignmentsByTruckOID[oid] = truckTriggersAndAssignments
        truckTriggersAndAssignments.append(
            {
                'time' : event.getTime(),
                'type' : 'assignment',
                'assignments' : event.getAssignments()
            }
        )

    def setTimeDifferencesInTriggersAndAssignmentsByTruckOID(self, triggersAndAssignmentsByTruckOID):
        """Traverse the list of triggers and assignments for each truck and set the time differences - internal use only
        """
        # An inner function to detect the next index of a given element type in the list of triggersAndAssignments:
        def getNextIndex(triggersAndAssignments, initialIndex, elementType):
            index = initialIndex + 1
            while (index < len(triggersAndAssignments)) and (triggersAndAssignments[index]['type'] != elementType):
                index = index + 1
            if index >= len(triggersAndAssignments):
                return -1
            return index
        # Iterate over the truck oid keys:
        for oid in triggersAndAssignmentsByTruckOID.keys():
            triggersAndAssignments = triggersAndAssignmentsByTruckOID[oid]
            elementCount = len(triggersAndAssignments)
            # Get the initial indices for the triggers, assignments and arrivals in the list of triggers and assignments for the truck:
            triggerIndex = getNextIndex(triggersAndAssignments, -1, 'trigger')
            assignmentIndex = getNextIndex(triggersAndAssignments, triggerIndex, 'assignment')
            while (triggerIndex >= 0) and (triggerIndex < elementCount) and (assignmentIndex >= 0) and (assignmentIndex < elementCount):
                triggerToAssignmentTimeDelta = triggersAndAssignments[assignmentIndex]['time'] - triggersAndAssignments[triggerIndex]['time']
                if (triggerToAssignmentTimeDelta.total_seconds() >= 0):
                    triggersAndAssignments[triggerIndex]['timeToAssignment'] = triggerToAssignmentTimeDelta
                    triggersAndAssignments[assignmentIndex]['timeFromTrigger'] = triggerToAssignmentTimeDelta
                triggerIndex = getNextIndex(triggersAndAssignments, triggerIndex, 'trigger')
                assignmentIndex = getNextIndex(triggersAndAssignments, assignmentIndex, 'assignment')
            assignmentIndex = getNextIndex(triggersAndAssignments, -1, 'assignment')
            arrivalIndex = getNextIndex(triggersAndAssignments, assignmentIndex, 'arrival')
            while (arrivalIndex >= 0) and (arrivalIndex < elementCount) and (assignmentIndex >= 0) and (assignmentIndex < elementCount):
                assignmentToArrivalTimeDelta = ''
                if (arrivalIndex >= 0) and (arrivalIndex < elementCount):
                    assignmentToArrivalTimeDelta = triggersAndAssignments[arrivalIndex]['arrivalTime'] - triggersAndAssignments[assignmentIndex]['time']
                if (assignmentToArrivalTimeDelta.total_seconds() >= 0):
                    triggersAndAssignments[assignmentIndex]['timeToArrival'] = assignmentToArrivalTimeDelta
                    triggersAndAssignments[arrivalIndex]['timeFromAssignment'] = assignmentToArrivalTimeDelta
                assignmentIndex = getNextIndex(triggersAndAssignments, assignmentIndex, 'assignment')
                arrivalIndex = getNextIndex(triggersAndAssignments, arrivalIndex, 'arrival')

    # This invokes getAssignmentEventsByTruckOID(), but adds or refreshes the validity checks for the forecast assignments
    # at each of the four levels in each assignment:
    def getAssignmentEventsWithForecastChecksByTruckOID(self):
        """
        Returns:
          A map of truck OIDs to lists of assignment events, with boolean flags set on each predicted assignment indicating whether
          the assignment occurred in a later event
        """
        assignmentEventsByOID = self.getAssignmentEventsByOID()
        for oid in assignmentEventsByOID.keys():
            # The last four assignments, including the current one (current, prev, prevPrev, prevPrevPrev, prevPrevPrevPrev):
            assignmentEvents = [ '', '', '', '' ]
            for assignmentEvent in assignmentEventsByOID[oid]:
                for i in [ 3, 2, 1 ]:
                    assignmentEvents[i] = assignmentEvents[i - 1]
                assignmentEvents[0] = assignmentEvent
                # Now, check for the forecast of the current assignmentEvent in each of the previous three assignments:
                for i in [ 1, 2, 3 ]:
                    if assignmentEvents[i]:
                        # the ith assignment in the ith previous AssignmentEvent (which should be the 0th assignment in the
                        # current assignmentEvent, i.e., the current assignment):
                        forecastAssignment = assignmentEvents[i].getAssignments()[i]
                        currentAssignment = assignmentEvents[0].getAssignments()[0]
                        if forecastAssignment['rcmDestinationQueueLocationOID'] == currentAssignment['rcmDestinationQueueLocationOID']:
                            forecastAssignment['occurred'] = True
                        else:
                            forecastAssignment['occurred'] = False
        return assignmentEventsByOID
